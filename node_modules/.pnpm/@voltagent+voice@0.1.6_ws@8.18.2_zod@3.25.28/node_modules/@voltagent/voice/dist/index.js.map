{"version":3,"sources":["../src/index.ts","../src/providers/base/index.ts","../src/providers/openai/index.ts","../src/providers/openai/types.ts","../src/providers/elevenlabs/index.ts","../src/providers/xsai/index.ts"],"sourcesContent":["export * from \"./types\";\nexport * from \"./providers/base\";\nexport * from \"./providers/openai\";\nexport * from \"./providers/elevenlabs\";\nexport * from \"./providers/xsai\";\n","import type { Voice, VoiceEventType, ReadableStreamType } from \"@voltagent/core\";\nimport type { BaseVoiceProviderEvents, BaseVoiceProviderOptions } from \"./types\";\n\nexport abstract class BaseVoiceProvider implements Voice {\n  protected options: BaseVoiceProviderOptions;\n  protected eventListeners: Map<VoiceEventType, Set<Function>>;\n\n  constructor(options: BaseVoiceProviderOptions = {}) {\n    this.options = options;\n    this.eventListeners = new Map();\n  }\n\n  abstract speak(\n    text: string | NodeJS.ReadableStream,\n    options?: {\n      voice?: string;\n      speed?: number;\n      pitch?: number;\n    },\n  ): Promise<NodeJS.ReadableStream>;\n\n  abstract listen(\n    audio: NodeJS.ReadableStream,\n    options?: {\n      language?: string;\n      model?: string;\n      stream?: boolean;\n    },\n  ): Promise<string | ReadableStreamType>;\n\n  abstract connect(options?: Record<string, unknown>): Promise<void>;\n  abstract disconnect(): void;\n  abstract send(audioData: NodeJS.ReadableStream | Int16Array): Promise<void>;\n  abstract getVoices(): Promise<\n    Array<{\n      id: string;\n      name: string;\n      language: string;\n      gender?: \"male\" | \"female\" | \"neutral\";\n      metadata?: Record<string, unknown>;\n    }>\n  >;\n\n  protected emit<E extends VoiceEventType>(event: E, data: BaseVoiceProviderEvents[E]): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach((listener) => listener(data));\n    }\n  }\n\n  on<E extends VoiceEventType>(\n    event: E,\n    callback: (data: BaseVoiceProviderEvents[E]) => void,\n  ): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event)?.add(callback);\n  }\n\n  off<E extends VoiceEventType>(\n    event: E,\n    callback: (data: BaseVoiceProviderEvents[E]) => void,\n  ): void {\n    this.eventListeners.get(event)?.delete(callback);\n  }\n}\n","import { PassThrough } from \"node:stream\";\nimport OpenAI from \"openai\";\nimport type { VoiceMetadata, ReadableStreamType } from \"@voltagent/core\";\nimport { BaseVoiceProvider } from \"../base\";\nimport type {\n  OpenAIAudioFormat,\n  OpenAIListenOptions,\n  OpenAISpeakOptions,\n  OpenAIVoiceOptions,\n} from \"./types\";\nimport { OPENAI_VOICES } from \"./types\";\n\n// Voice metadata mapping\nconst VOICE_METADATA: Record<string, VoiceMetadata> = {\n  alloy: { id: \"alloy\", name: \"Alloy\", language: \"en\", gender: \"neutral\" },\n  echo: { id: \"echo\", name: \"Echo\", language: \"en\", gender: \"male\" },\n  fable: { id: \"fable\", name: \"Fable\", language: \"en\", gender: \"male\" },\n  onyx: { id: \"onyx\", name: \"Onyx\", language: \"en\", gender: \"male\" },\n  nova: { id: \"nova\", name: \"Nova\", language: \"en\", gender: \"female\" },\n  shimmer: { id: \"shimmer\", name: \"Shimmer\", language: \"en\", gender: \"female\" },\n  ash: { id: \"ash\", name: \"Ash\", language: \"en\", gender: \"male\" },\n  coral: { id: \"coral\", name: \"Coral\", language: \"en\", gender: \"female\" },\n  sage: { id: \"sage\", name: \"Sage\", language: \"en\", gender: \"male\" },\n};\n\nexport class OpenAIVoiceProvider extends BaseVoiceProvider {\n  private readonly client: OpenAI;\n  private readonly speechModel: string;\n  private readonly ttsModel: string;\n  private readonly voice: OpenAIVoiceOptions[\"voice\"];\n\n  constructor(options: OpenAIVoiceOptions) {\n    super(options);\n    this.speechModel = options.speechModel || \"gpt-4o-mini-transcribe\";\n    this.ttsModel = options.ttsModel || \"tts-1\";\n    this.voice = options.voice || \"alloy\";\n\n    this.client = new OpenAI({\n      apiKey: options.apiKey,\n      organization: options.options?.organization,\n      timeout: options.options?.timeout,\n      maxRetries: options.options?.maxRetries,\n    });\n  }\n\n  /**\n   * Convert text to speech\n   * @param text Text to convert to speech\n   * @param options Options for text-to-speech\n   * @returns Audio stream\n   */\n  async speak(\n    text: string | NodeJS.ReadableStream,\n    options?: OpenAISpeakOptions & { voice?: OpenAIVoiceOptions[\"voice\"] },\n  ): Promise<NodeJS.ReadableStream> {\n    try {\n      // Convert stream to string if needed\n      let inputText: string;\n      if (typeof text === \"string\") {\n        inputText = text;\n      } else {\n        const chunks: Buffer[] = [];\n        for await (const chunk of text) {\n          if (typeof chunk === \"string\") {\n            chunks.push(Buffer.from(chunk));\n          } else {\n            chunks.push(chunk);\n          }\n        }\n        inputText = Buffer.concat(chunks).toString(\"utf-8\");\n      }\n\n      if (inputText.trim().length === 0) {\n        throw new Error(\"Input text is empty\");\n      }\n\n      // Emit speaking event\n      this.emit(\"speaking\", { text: inputText });\n\n      // Generate speech\n      const voice = options?.voice || this.voice;\n      if (!voice) {\n        throw new Error(\"Voice is required\");\n      }\n\n      const response = await this.client.audio.speech.create({\n        model: this.ttsModel,\n        voice,\n        input: inputText,\n        ...options,\n      });\n\n      // Convert response to stream\n      const passThrough = new PassThrough();\n      const buffer = Buffer.from(await response.arrayBuffer());\n      passThrough.end(buffer);\n      return passThrough;\n    } catch (error) {\n      this.emit(\"error\", {\n        message: error instanceof Error ? error.message : \"Unknown error occurred\",\n        code: \"SPEAK_ERROR\",\n        details: error,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Convert speech to text\n   * @param audio Audio stream to transcribe\n   * @param options Options for speech-to-text\n   * @returns Transcribed text or stream of transcribed text\n   */\n  async listen(\n    audio: NodeJS.ReadableStream,\n    options?: OpenAIListenOptions & {\n      format?: OpenAIAudioFormat;\n      stream?: boolean;\n    },\n  ): Promise<string | ReadableStreamType> {\n    try {\n      // Emit listening event\n      this.emit(\"listening\", { audio });\n\n      // Convert stream to buffer\n      const chunks: Buffer[] = [];\n      for await (const chunk of audio) {\n        if (typeof chunk === \"string\") {\n          chunks.push(Buffer.from(chunk));\n        } else {\n          chunks.push(chunk);\n        }\n      }\n      const audioBuffer = Buffer.concat(chunks);\n\n      // Create file for OpenAI API\n      const format = options?.format || \"mp3\";\n      const mimeTypes: Record<OpenAIAudioFormat, string> = {\n        mp3: \"audio/mpeg\",\n        mp4: \"audio/mp4\",\n        mpeg: \"audio/mpeg\",\n        mpga: \"audio/mpeg\",\n        m4a: \"audio/mp4\",\n        wav: \"audio/wav\",\n        webm: \"audio/webm\",\n      };\n\n      const file = new File([audioBuffer], `audio.${format}`, {\n        type: mimeTypes[format],\n      });\n\n      // Transcribe audio\n      if (options?.stream) {\n        const response = await this.client.audio.transcriptions.create({\n          model: this.speechModel,\n          file: file as unknown as File,\n          stream: true,\n          response_format: \"text\",\n          ...options,\n        } as OpenAI.Audio.Transcriptions.TranscriptionCreateParamsStreaming);\n\n        return response;\n      }\n\n      // Non-streaming transcription\n      const response = await this.client.audio.transcriptions.create({\n        model: this.speechModel,\n        file: file as unknown as File,\n        stream: false,\n        ...options,\n      } as OpenAI.Audio.Transcriptions.TranscriptionCreateParamsNonStreaming);\n\n      return response.text;\n    } catch (error) {\n      this.emit(\"error\", {\n        message: error instanceof Error ? error.message : \"Unknown error occurred\",\n        code: \"LISTEN_ERROR\",\n        details: error,\n      });\n      throw error;\n    }\n  }\n\n  async connect(): Promise<void> {\n    // OpenAI doesn't support real-time streaming\n    throw new Error(\"Real-time streaming not supported by OpenAI\");\n  }\n\n  disconnect(): void {\n    // No-op\n  }\n\n  async send(): Promise<void> {\n    // OpenAI doesn't support real-time streaming\n    throw new Error(\"Real-time streaming not supported by OpenAI\");\n  }\n\n  async getVoices(): Promise<VoiceMetadata[]> {\n    return OPENAI_VOICES.map((voice) => VOICE_METADATA[voice]);\n  }\n}\n","import type { SpeechCreateParams } from \"openai/resources/audio/speech\";\nimport type { TranscriptionCreateParams } from \"openai/resources/audio/transcriptions\";\nimport type { BaseVoiceProviderOptions } from \"../base/types\";\n\nexport const OPENAI_VOICES = [\n  \"alloy\",\n  \"echo\",\n  \"fable\",\n  \"onyx\",\n  \"nova\",\n  \"shimmer\",\n  \"ash\",\n  \"coral\",\n  \"sage\",\n] as const;\n\nexport type OpenAIVoice = (typeof OPENAI_VOICES)[number];\n\n/**\n * OpenAI voice options\n */\nexport type OpenAIVoiceOptions = BaseVoiceProviderOptions & {\n  /**\n   * OpenAI API key\n   */\n  apiKey: string;\n\n  /**\n   * Model to use for speech recognition\n   * @default \"whisper-1\"\n   */\n  speechModel?: string;\n\n  /**\n   * Model to use for text-to-speech\n   * @default \"tts-1\"\n   */\n  ttsModel?: string;\n\n  /**\n   * Voice to use for text-to-speech\n   * @default \"alloy\"\n   */\n  voice?: OpenAIVoice;\n\n  /**\n   * Additional OpenAI API options\n   */\n  options?: {\n    /**\n     * Organization ID\n     */\n    organization?: string;\n\n    /**\n     * Request timeout in milliseconds\n     */\n    timeout?: number;\n\n    /**\n     * Maximum retries for failed requests\n     */\n    maxRetries?: number;\n  };\n};\n\n/**\n * Options for text-to-speech\n */\nexport type OpenAISpeakOptions = Omit<SpeechCreateParams, \"model\" | \"voice\" | \"input\">;\n\n/**\n * Options for speech-to-text\n */\nexport type OpenAIListenOptions = Omit<TranscriptionCreateParams, \"model\" | \"file\" | \"stream\"> & {\n  /**\n   * Whether to stream the transcription\n   * @default false\n   */\n  stream?: boolean;\n};\n\n/**\n * Supported audio formats\n */\nexport type OpenAIAudioFormat = \"mp3\" | \"mp4\" | \"mpeg\" | \"mpga\" | \"m4a\" | \"wav\" | \"webm\";\n","import { ElevenLabsClient } from \"elevenlabs\";\nimport type { Voice as ElevenLabsVoice } from \"elevenlabs/api/types/Voice\";\nimport type { VoiceMetadata } from \"@voltagent/core\";\nimport { BaseVoiceProvider } from \"../base\";\nimport type { ElevenLabsModel, ElevenLabsVoiceOptions } from \"./types\";\nimport { Readable } from \"node:stream\";\n\nexport class ElevenLabsVoiceProvider extends BaseVoiceProvider {\n  private readonly client: ElevenLabsClient;\n  private readonly speechModel: ElevenLabsModel;\n  private readonly ttsModel: ElevenLabsModel;\n  private readonly voice: string;\n  private readonly voiceSettings: NonNullable<ElevenLabsVoiceOptions[\"options\"]>;\n\n  constructor(options: ElevenLabsVoiceOptions) {\n    super(options);\n    this.speechModel = options.speechModel || \"scribe_v1\";\n    this.ttsModel = options.ttsModel || \"eleven_multilingual_v2\";\n    this.voice = options.voice || \"Callum\";\n    this.voiceSettings = {\n      stability: options.options?.stability ?? 0.5,\n      similarityBoost: options.options?.similarityBoost ?? 0.75,\n      style: options.options?.style ?? 0,\n      useSpeakerBoost: options.options?.useSpeakerBoost ?? true,\n    };\n\n    this.client = new ElevenLabsClient({\n      apiKey: options.apiKey,\n    });\n  }\n\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    options?: {\n      voice?: string;\n      stability?: number;\n      similarityBoost?: number;\n      style?: number;\n      useSpeakerBoost?: boolean;\n    },\n  ): Promise<NodeJS.ReadableStream> {\n    try {\n      // Convert stream to string if needed\n      let text: string;\n      if (typeof input === \"string\") {\n        text = input;\n      } else {\n        const chunks: Buffer[] = [];\n        for await (const chunk of input) {\n          if (typeof chunk === \"string\") {\n            chunks.push(Buffer.from(chunk));\n          } else {\n            chunks.push(chunk);\n          }\n        }\n        text = Buffer.concat(chunks).toString(\"utf-8\");\n      }\n\n      if (text.trim().length === 0) {\n        throw new Error(\"Input text is empty\");\n      }\n\n      // Emit speaking event\n      this.emit(\"speaking\", { text });\n\n      // Generate speech\n      const voice = options?.voice || this.voice;\n      if (!voice) {\n        throw new Error(\"Voice is required\");\n      }\n\n      const audioStream = await this.client.generate({\n        text,\n        voice: voice,\n        model_id: this.ttsModel,\n        voice_settings: {\n          stability: options?.stability ?? this.voiceSettings.stability,\n          similarity_boost: options?.similarityBoost ?? this.voiceSettings.similarityBoost,\n          style: options?.style ?? this.voiceSettings.style,\n          use_speaker_boost: options?.useSpeakerBoost ?? this.voiceSettings.useSpeakerBoost,\n        },\n        stream: true,\n      });\n\n      // Convert the AsyncIterable stream to a readable stream\n      const response = Readable.from(audioStream);\n\n      return response;\n    } catch (error) {\n      this.emit(\"error\", {\n        message: error instanceof Error ? error.message : \"Unknown error occurred\",\n        code: \"SPEAK_ERROR\",\n        details: error,\n      });\n      throw error;\n    }\n  }\n\n  async listen(\n    audio: NodeJS.ReadableStream,\n    options?: {\n      language?: string;\n      model?: ElevenLabsModel;\n      tagAudioEvents?: boolean;\n      numSpeakers?: number;\n      fileType?: string;\n    },\n  ): Promise<string> {\n    try {\n      // Emit listening event\n      this.emit(\"listening\", { audio });\n\n      // Convert stream to buffer\n      const chunks: Buffer[] = [];\n      for await (const chunk of audio) {\n        if (typeof chunk === \"string\") {\n          chunks.push(Buffer.from(chunk));\n        } else {\n          chunks.push(chunk);\n        }\n      }\n      const audioBuffer = Buffer.concat(chunks);\n\n      // Create file for ElevenLabs API\n      const file = new File([audioBuffer], `audio.${options?.fileType || \"mp3\"}`);\n\n      // Transcribe audio\n      const response = await this.client.speechToText.convert({\n        file,\n        model_id: options?.model || this.speechModel,\n        language_code: options?.language,\n        tag_audio_events: options?.tagAudioEvents,\n        num_speakers: options?.numSpeakers,\n      });\n\n      return response.text;\n    } catch (error) {\n      this.emit(\"error\", {\n        message: error instanceof Error ? error.message : \"Unknown error occurred\",\n        code: \"LISTEN_ERROR\",\n        details: error,\n      });\n      throw error;\n    }\n  }\n\n  async connect(): Promise<void> {\n    // ElevenLabs doesn't support real-time streaming\n    throw new Error(\"Real-time streaming not supported by ElevenLabs\");\n  }\n\n  disconnect(): void {\n    // No-op\n  }\n\n  async send(): Promise<void> {\n    // ElevenLabs doesn't support real-time streaming\n    throw new Error(\"Real-time streaming not supported by ElevenLabs\");\n  }\n\n  async getVoices(): Promise<VoiceMetadata[]> {\n    const voices = await this.client.voices.getAll();\n    return voices.voices.map((voice: ElevenLabsVoice) => ({\n      id: voice.voice_id,\n      name: voice.name || \"Unknown Voice\",\n      language: voice.labels?.language || \"en\",\n      gender: (voice.labels?.gender?.toLowerCase() as \"male\" | \"female\" | \"neutral\") || \"neutral\",\n    }));\n  }\n}\n","import { PassThrough } from \"node:stream\";\nimport type { VoiceMetadata, ReadableStreamType } from \"@voltagent/core\";\nimport { BaseVoiceProvider } from \"../base\";\nimport { XsaiVoiceOptions, XsaiSpeakOptions, XsaiListenOptions } from \"./types\";\nimport { generateSpeech, GenerateSpeechOptions } from \"@xsai/generate-speech\";\nimport { generateTranscription, GenerateTranscriptionOptions } from \"@xsai/generate-transcription\";\n\n/* ------------------------------------------------------------------ */\n/*  Helper: bufferise a Node stream                                   */\n/* ------------------------------------------------------------------ */\nasync function collectChunks(stream: NodeJS.ReadableStream): Promise<Buffer> {\n  const chunks: Buffer[] = [];\n  for await (const c of stream) {\n    chunks.push(typeof c === \"string\" ? Buffer.from(c) : c);\n  }\n  return Buffer.concat(chunks);\n}\n\n/* ------------------------------------------------------------------ */\n/*  xsAI provider                                                     */\n/* ------------------------------------------------------------------ */\nexport class XsAIVoiceProvider extends BaseVoiceProvider {\n  private readonly apiKey: string;\n  private readonly baseURL: string;\n  private readonly ttsModel: string;\n  private readonly speechModel: string;\n  private readonly voice: string;\n  private readonly headers?: Record<string, string>;\n\n  constructor(options: XsaiVoiceOptions) {\n    super(options);\n\n    this.apiKey = options.apiKey;\n    this.baseURL = options.baseURL ?? \"https://api.openai.com/v1\";\n    this.ttsModel = options.ttsModel ?? \"tts-1\";\n    this.speechModel = options.speechModel ?? \"whisper-1\";\n    this.voice = options.voice ?? \"alloy\";\n    this.headers = options.options?.headers;\n  }\n\n  /* ------------------------------------------------------------------ */\n  /*  TEXT ➜ SPEECH                                                     */\n  /* ------------------------------------------------------------------ */\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    opts: XsaiSpeakOptions = {},\n  ): Promise<NodeJS.ReadableStream> {\n    try {\n      const text =\n        typeof input === \"string\" ? input : (await collectChunks(input)).toString(\"utf8\");\n\n      if (!text.trim()) throw new Error(\"Input text is empty\");\n      this.emit(\"speaking\", { text });\n\n      // Dynamically import the module\n\n      const generateSpeechOptions: GenerateSpeechOptions = {\n        input: text,\n        voice: opts.voice ?? this.voice ?? \"default\",\n        responseFormat: opts.format ?? \"mp3\",\n        speed: opts.speed ?? 1.0,\n        /* CommonRequestOptions */\n        apiKey: this.apiKey,\n        baseURL: this.baseURL,\n        model: this.ttsModel,\n        headers: this.headers,\n      };\n\n      const arrayBuf = await generateSpeech(generateSpeechOptions);\n\n      const stream = new PassThrough();\n      stream.end(Buffer.from(arrayBuf));\n      return stream;\n    } catch (err) {\n      this.emit(\"error\", {\n        message: err instanceof Error ? err.message : \"Unknown error\",\n        code: \"SPEAK_ERROR\",\n        details: err,\n      });\n      throw err;\n    }\n  }\n\n  /* ------------------------------------------------------------------ */\n  /*  SPEECH ➜ TEXT                                                     */\n  /* ------------------------------------------------------------------ */\n  async listen(\n    audio: NodeJS.ReadableStream,\n    opts: XsaiListenOptions = {},\n  ): Promise<string | ReadableStreamType> {\n    try {\n      this.emit(\"listening\", { audio });\n      const buf = await collectChunks(audio);\n\n      const blob = new Blob([buf]);\n\n      const generateTranscriptionOptions: GenerateTranscriptionOptions = {\n        file: blob,\n        fileName: opts.fileName ?? \"audio.wav\",\n        language: opts.language,\n        prompt: opts.prompt,\n        temperature: opts.temperature,\n        /* CommonRequestOptions */\n        apiKey: this.apiKey,\n        baseURL: this.baseURL,\n        model: this.speechModel,\n        headers: this.headers,\n      };\n\n      const { text } = await generateTranscription(generateTranscriptionOptions);\n\n      return text;\n    } catch (err) {\n      this.emit(\"error\", {\n        message: err instanceof Error ? err.message : \"Unknown error\",\n        code: \"LISTEN_ERROR\",\n        details: err,\n      });\n      throw err;\n    }\n  }\n\n  /* ------------------------------------------------------------------ */\n  /*  Real‑time streaming not yet available                             */\n  /* ------------------------------------------------------------------ */\n  async connect(): Promise<void> {\n    throw new Error(\"Real‑time streaming not supported by xsAI\");\n  }\n  disconnect(): void {\n    /* noop */\n  }\n  async send(): Promise<void> {\n    throw new Error(\"Real‑time streaming not supported by xsAI\");\n  }\n\n  /* ------------------------------------------------------------------ */\n  /*  xsAI hasn't published a voice list API – stub with default        */\n  /* ------------------------------------------------------------------ */\n  async getVoices(): Promise<VoiceMetadata[]> {\n    return [\n      {\n        id: this.voice ?? \"default\",\n        name: \"xsAI default\",\n        language: \"en\",\n        gender: \"neutral\",\n      },\n    ];\n  }\n}\n"],"mappings":"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","names":["OpenAI","error","response","import_node_stream","error","import_node_stream"]}