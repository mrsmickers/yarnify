"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => {
  it = obj[Symbol.asyncIterator];
  method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((resolve, reject, done) => {
    arg = fn.call(obj, arg);
    done = arg.done;
    return Promise.resolve(arg.value).then((value) => resolve({ value, done }), reject);
  }));
  return it ? it.call(obj) : (obj = obj[Symbol.iterator](), it = {}, method("next"), method("return"), it);
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BaseVoiceProvider: () => BaseVoiceProvider,
  ElevenLabsVoiceProvider: () => ElevenLabsVoiceProvider,
  OpenAIVoiceProvider: () => OpenAIVoiceProvider,
  XsAIVoiceProvider: () => XsAIVoiceProvider
});
module.exports = __toCommonJS(src_exports);

// src/providers/base/index.ts
var BaseVoiceProvider = class {
  constructor(options = {}) {
    this.options = options;
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  emit(event, data) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach((listener) => listener(data));
    }
  }
  on(event, callback) {
    var _a;
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, /* @__PURE__ */ new Set());
    }
    (_a = this.eventListeners.get(event)) == null ? void 0 : _a.add(callback);
  }
  off(event, callback) {
    var _a;
    (_a = this.eventListeners.get(event)) == null ? void 0 : _a.delete(callback);
  }
};
__name(BaseVoiceProvider, "BaseVoiceProvider");

// src/providers/openai/index.ts
var import_node_stream = require("stream");
var import_openai = __toESM(require("openai"));

// src/providers/openai/types.ts
var OPENAI_VOICES = [
  "alloy",
  "echo",
  "fable",
  "onyx",
  "nova",
  "shimmer",
  "ash",
  "coral",
  "sage"
];

// src/providers/openai/index.ts
var VOICE_METADATA = {
  alloy: { id: "alloy", name: "Alloy", language: "en", gender: "neutral" },
  echo: { id: "echo", name: "Echo", language: "en", gender: "male" },
  fable: { id: "fable", name: "Fable", language: "en", gender: "male" },
  onyx: { id: "onyx", name: "Onyx", language: "en", gender: "male" },
  nova: { id: "nova", name: "Nova", language: "en", gender: "female" },
  shimmer: { id: "shimmer", name: "Shimmer", language: "en", gender: "female" },
  ash: { id: "ash", name: "Ash", language: "en", gender: "male" },
  coral: { id: "coral", name: "Coral", language: "en", gender: "female" },
  sage: { id: "sage", name: "Sage", language: "en", gender: "male" }
};
var OpenAIVoiceProvider = class extends BaseVoiceProvider {
  constructor(options) {
    var _a, _b, _c;
    super(options);
    this.speechModel = options.speechModel || "gpt-4o-mini-transcribe";
    this.ttsModel = options.ttsModel || "tts-1";
    this.voice = options.voice || "alloy";
    this.client = new import_openai.default({
      apiKey: options.apiKey,
      organization: (_a = options.options) == null ? void 0 : _a.organization,
      timeout: (_b = options.options) == null ? void 0 : _b.timeout,
      maxRetries: (_c = options.options) == null ? void 0 : _c.maxRetries
    });
  }
  /**
   * Convert text to speech
   * @param text Text to convert to speech
   * @param options Options for text-to-speech
   * @returns Audio stream
   */
  speak(text, options) {
    return __async(this, null, function* () {
      try {
        let inputText;
        if (typeof text === "string") {
          inputText = text;
        } else {
          const chunks = [];
          try {
            for (var iter = __forAwait(text), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const chunk = temp.value;
              if (typeof chunk === "string") {
                chunks.push(Buffer.from(chunk));
              } else {
                chunks.push(chunk);
              }
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          inputText = Buffer.concat(chunks).toString("utf-8");
        }
        if (inputText.trim().length === 0) {
          throw new Error("Input text is empty");
        }
        this.emit("speaking", { text: inputText });
        const voice = (options == null ? void 0 : options.voice) || this.voice;
        if (!voice) {
          throw new Error("Voice is required");
        }
        const response = yield this.client.audio.speech.create(__spreadValues({
          model: this.ttsModel,
          voice,
          input: inputText
        }, options));
        const passThrough = new import_node_stream.PassThrough();
        const buffer = Buffer.from(yield response.arrayBuffer());
        passThrough.end(buffer);
        return passThrough;
      } catch (error2) {
        this.emit("error", {
          message: error2 instanceof Error ? error2.message : "Unknown error occurred",
          code: "SPEAK_ERROR",
          details: error2
        });
        throw error2;
      }
    });
  }
  /**
   * Convert speech to text
   * @param audio Audio stream to transcribe
   * @param options Options for speech-to-text
   * @returns Transcribed text or stream of transcribed text
   */
  listen(audio, options) {
    return __async(this, null, function* () {
      try {
        this.emit("listening", { audio });
        const chunks = [];
        try {
          for (var iter = __forAwait(audio), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const chunk = temp.value;
            if (typeof chunk === "string") {
              chunks.push(Buffer.from(chunk));
            } else {
              chunks.push(chunk);
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        const audioBuffer = Buffer.concat(chunks);
        const format = (options == null ? void 0 : options.format) || "mp3";
        const mimeTypes = {
          mp3: "audio/mpeg",
          mp4: "audio/mp4",
          mpeg: "audio/mpeg",
          mpga: "audio/mpeg",
          m4a: "audio/mp4",
          wav: "audio/wav",
          webm: "audio/webm"
        };
        const file = new File([audioBuffer], `audio.${format}`, {
          type: mimeTypes[format]
        });
        if (options == null ? void 0 : options.stream) {
          const response2 = yield this.client.audio.transcriptions.create(__spreadValues({
            model: this.speechModel,
            file,
            stream: true,
            response_format: "text"
          }, options));
          return response2;
        }
        const response = yield this.client.audio.transcriptions.create(__spreadValues({
          model: this.speechModel,
          file,
          stream: false
        }, options));
        return response.text;
      } catch (error2) {
        this.emit("error", {
          message: error2 instanceof Error ? error2.message : "Unknown error occurred",
          code: "LISTEN_ERROR",
          details: error2
        });
        throw error2;
      }
    });
  }
  connect() {
    return __async(this, null, function* () {
      throw new Error("Real-time streaming not supported by OpenAI");
    });
  }
  disconnect() {
  }
  send() {
    return __async(this, null, function* () {
      throw new Error("Real-time streaming not supported by OpenAI");
    });
  }
  getVoices() {
    return __async(this, null, function* () {
      return OPENAI_VOICES.map((voice) => VOICE_METADATA[voice]);
    });
  }
};
__name(OpenAIVoiceProvider, "OpenAIVoiceProvider");

// src/providers/elevenlabs/index.ts
var import_elevenlabs = require("elevenlabs");
var import_node_stream2 = require("stream");
var ElevenLabsVoiceProvider = class extends BaseVoiceProvider {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super(options);
    this.speechModel = options.speechModel || "scribe_v1";
    this.ttsModel = options.ttsModel || "eleven_multilingual_v2";
    this.voice = options.voice || "Callum";
    this.voiceSettings = {
      stability: (_b = (_a = options.options) == null ? void 0 : _a.stability) != null ? _b : 0.5,
      similarityBoost: (_d = (_c = options.options) == null ? void 0 : _c.similarityBoost) != null ? _d : 0.75,
      style: (_f = (_e = options.options) == null ? void 0 : _e.style) != null ? _f : 0,
      useSpeakerBoost: (_h = (_g = options.options) == null ? void 0 : _g.useSpeakerBoost) != null ? _h : true
    };
    this.client = new import_elevenlabs.ElevenLabsClient({
      apiKey: options.apiKey
    });
  }
  speak(input, options) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      try {
        let text;
        if (typeof input === "string") {
          text = input;
        } else {
          const chunks = [];
          try {
            for (var iter = __forAwait(input), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
              const chunk = temp.value;
              if (typeof chunk === "string") {
                chunks.push(Buffer.from(chunk));
              } else {
                chunks.push(chunk);
              }
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield temp.call(iter));
            } finally {
              if (error)
                throw error[0];
            }
          }
          text = Buffer.concat(chunks).toString("utf-8");
        }
        if (text.trim().length === 0) {
          throw new Error("Input text is empty");
        }
        this.emit("speaking", { text });
        const voice = (options == null ? void 0 : options.voice) || this.voice;
        if (!voice) {
          throw new Error("Voice is required");
        }
        const audioStream = yield this.client.generate({
          text,
          voice,
          model_id: this.ttsModel,
          voice_settings: {
            stability: (_a = options == null ? void 0 : options.stability) != null ? _a : this.voiceSettings.stability,
            similarity_boost: (_b = options == null ? void 0 : options.similarityBoost) != null ? _b : this.voiceSettings.similarityBoost,
            style: (_c = options == null ? void 0 : options.style) != null ? _c : this.voiceSettings.style,
            use_speaker_boost: (_d = options == null ? void 0 : options.useSpeakerBoost) != null ? _d : this.voiceSettings.useSpeakerBoost
          },
          stream: true
        });
        const response = import_node_stream2.Readable.from(audioStream);
        return response;
      } catch (error2) {
        this.emit("error", {
          message: error2 instanceof Error ? error2.message : "Unknown error occurred",
          code: "SPEAK_ERROR",
          details: error2
        });
        throw error2;
      }
    });
  }
  listen(audio, options) {
    return __async(this, null, function* () {
      try {
        this.emit("listening", { audio });
        const chunks = [];
        try {
          for (var iter = __forAwait(audio), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const chunk = temp.value;
            if (typeof chunk === "string") {
              chunks.push(Buffer.from(chunk));
            } else {
              chunks.push(chunk);
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        const audioBuffer = Buffer.concat(chunks);
        const file = new File([audioBuffer], `audio.${(options == null ? void 0 : options.fileType) || "mp3"}`);
        const response = yield this.client.speechToText.convert({
          file,
          model_id: (options == null ? void 0 : options.model) || this.speechModel,
          language_code: options == null ? void 0 : options.language,
          tag_audio_events: options == null ? void 0 : options.tagAudioEvents,
          num_speakers: options == null ? void 0 : options.numSpeakers
        });
        return response.text;
      } catch (error2) {
        this.emit("error", {
          message: error2 instanceof Error ? error2.message : "Unknown error occurred",
          code: "LISTEN_ERROR",
          details: error2
        });
        throw error2;
      }
    });
  }
  connect() {
    return __async(this, null, function* () {
      throw new Error("Real-time streaming not supported by ElevenLabs");
    });
  }
  disconnect() {
  }
  send() {
    return __async(this, null, function* () {
      throw new Error("Real-time streaming not supported by ElevenLabs");
    });
  }
  getVoices() {
    return __async(this, null, function* () {
      const voices = yield this.client.voices.getAll();
      return voices.voices.map((voice) => {
        var _a, _b, _c;
        return {
          id: voice.voice_id,
          name: voice.name || "Unknown Voice",
          language: ((_a = voice.labels) == null ? void 0 : _a.language) || "en",
          gender: ((_c = (_b = voice.labels) == null ? void 0 : _b.gender) == null ? void 0 : _c.toLowerCase()) || "neutral"
        };
      });
    });
  }
};
__name(ElevenLabsVoiceProvider, "ElevenLabsVoiceProvider");

// src/providers/xsai/index.ts
var import_node_stream3 = require("stream");
var import_generate_speech = require("@xsai/generate-speech");
var import_generate_transcription = require("@xsai/generate-transcription");
function collectChunks(stream) {
  return __async(this, null, function* () {
    const chunks = [];
    try {
      for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const c = temp.value;
        chunks.push(typeof c === "string" ? Buffer.from(c) : c);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    return Buffer.concat(chunks);
  });
}
__name(collectChunks, "collectChunks");
var XsAIVoiceProvider = class extends BaseVoiceProvider {
  constructor(options) {
    var _a, _b, _c, _d, _e;
    super(options);
    this.apiKey = options.apiKey;
    this.baseURL = (_a = options.baseURL) != null ? _a : "https://api.openai.com/v1";
    this.ttsModel = (_b = options.ttsModel) != null ? _b : "tts-1";
    this.speechModel = (_c = options.speechModel) != null ? _c : "whisper-1";
    this.voice = (_d = options.voice) != null ? _d : "alloy";
    this.headers = (_e = options.options) == null ? void 0 : _e.headers;
  }
  /* ------------------------------------------------------------------ */
  /*  TEXT ➜ SPEECH                                                     */
  /* ------------------------------------------------------------------ */
  speak(_0) {
    return __async(this, arguments, function* (input, opts = {}) {
      var _a, _b, _c, _d;
      try {
        const text = typeof input === "string" ? input : (yield collectChunks(input)).toString("utf8");
        if (!text.trim())
          throw new Error("Input text is empty");
        this.emit("speaking", { text });
        const generateSpeechOptions = {
          input: text,
          voice: (_b = (_a = opts.voice) != null ? _a : this.voice) != null ? _b : "default",
          responseFormat: (_c = opts.format) != null ? _c : "mp3",
          speed: (_d = opts.speed) != null ? _d : 1,
          /* CommonRequestOptions */
          apiKey: this.apiKey,
          baseURL: this.baseURL,
          model: this.ttsModel,
          headers: this.headers
        };
        const arrayBuf = yield (0, import_generate_speech.generateSpeech)(generateSpeechOptions);
        const stream = new import_node_stream3.PassThrough();
        stream.end(Buffer.from(arrayBuf));
        return stream;
      } catch (err) {
        this.emit("error", {
          message: err instanceof Error ? err.message : "Unknown error",
          code: "SPEAK_ERROR",
          details: err
        });
        throw err;
      }
    });
  }
  /* ------------------------------------------------------------------ */
  /*  SPEECH ➜ TEXT                                                     */
  /* ------------------------------------------------------------------ */
  listen(_0) {
    return __async(this, arguments, function* (audio, opts = {}) {
      var _a;
      try {
        this.emit("listening", { audio });
        const buf = yield collectChunks(audio);
        const blob = new Blob([buf]);
        const generateTranscriptionOptions = {
          file: blob,
          fileName: (_a = opts.fileName) != null ? _a : "audio.wav",
          language: opts.language,
          prompt: opts.prompt,
          temperature: opts.temperature,
          /* CommonRequestOptions */
          apiKey: this.apiKey,
          baseURL: this.baseURL,
          model: this.speechModel,
          headers: this.headers
        };
        const { text } = yield (0, import_generate_transcription.generateTranscription)(generateTranscriptionOptions);
        return text;
      } catch (err) {
        this.emit("error", {
          message: err instanceof Error ? err.message : "Unknown error",
          code: "LISTEN_ERROR",
          details: err
        });
        throw err;
      }
    });
  }
  /* ------------------------------------------------------------------ */
  /*  Real‑time streaming not yet available                             */
  /* ------------------------------------------------------------------ */
  connect() {
    return __async(this, null, function* () {
      throw new Error("Real\u2011time streaming not supported by xsAI");
    });
  }
  disconnect() {
  }
  send() {
    return __async(this, null, function* () {
      throw new Error("Real\u2011time streaming not supported by xsAI");
    });
  }
  /* ------------------------------------------------------------------ */
  /*  xsAI hasn't published a voice list API – stub with default        */
  /* ------------------------------------------------------------------ */
  getVoices() {
    return __async(this, null, function* () {
      var _a;
      return [
        {
          id: (_a = this.voice) != null ? _a : "default",
          name: "xsAI default",
          language: "en",
          gender: "neutral"
        }
      ];
    });
  }
};
__name(XsAIVoiceProvider, "XsAIVoiceProvider");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseVoiceProvider,
  ElevenLabsVoiceProvider,
  OpenAIVoiceProvider,
  XsAIVoiceProvider
});
//# sourceMappingURL=index.js.map