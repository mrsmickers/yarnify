"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.middleware = exports.verifyMessage = exports.verifyCallback = void 0;
/*
 * Created by kgrube on 4/3/2019
 */
const axios_1 = __importDefault(require("axios"));
const crypto_1 = __importDefault(require("crypto"));
/**
 * Load signing key and verify the message
 * @param callbackBody -
 * @param contentSignature - base64 content signature req.headers[x-content-signature]
 * @returns verifies callback signature
 * @public
 */
function verifyCallback(callbackBody, contentSignature) {
    return new Promise((resolve, reject) => {
        if (!callbackBody || !contentSignature) {
            throw new Error('callbackBody and contentSignature must be defined.');
        }
        const key_url = callbackBody.Metadata && callbackBody.Metadata.key_url;
        axios_1.default
            .get(key_url)
            .then((response) => {
            const body = response.data;
            try {
                const parsed = JSON.parse(body);
                const signingKey = parsed.signing_key;
                return resolve(verifyMessage(callbackBody, contentSignature, signingKey));
            }
            catch (parseErr) {
                return reject(parseErr);
            }
        })
            .catch((err) => reject(err));
    });
}
exports.verifyCallback = verifyCallback;
/**
 * Validate a callback body against signed key
 * @param callbackBody -
 * @param contentSignature -
 * @param signingKey -
 * @returns boolean if verified
 * @public
 */
function verifyMessage(callbackBody, contentSignature, signingKey) {
    const hash = crypto_1.default.createHash('sha256').update(signingKey).digest();
    const hmac = crypto_1.default.createHmac('sha256', hash);
    return contentSignature === hmac.update(JSON.stringify(callbackBody)).digest('base64');
}
exports.verifyMessage = verifyMessage;
/**
 *
 * @example
 * Express style middleware
 * ```
 * app.post('/your/api', cw.utils.middleware((err, req, res, verified, payload) => {
 *  if (err) {
 *    //handle error
 *    res.status(500).end();
 *  } else if (!verified) {
 *    // send 403 on verification failure
 *    res.status(403).end();
 *  } else {
 *    res.status(200).end()
 *  }
 *  const {action, id} = req.query;
 *  // do something with the payload
 * }));
 * ```
 *
 * @param cb - callback(err, req, res, verified, payload)
 * @public
 */
function middleware(cb) {
    if (!cb || typeof cb !== 'function') {
        throw new Error('callback must be a function.');
    }
    return (req, res) => {
        if (!req || !req.body || !req.body.Metadata) {
            return cb(new Error('callback payload is invalid.'), req, res, false, undefined);
        }
        const contentSignature = req.headers['x-content-signature'];
        const callbackBody = req.body;
        let parsedEntity;
        try {
            parsedEntity = JSON.parse(callbackBody.Entity);
        }
        catch (parseErr) {
            if (parseErr instanceof Error) {
                return cb(parseErr, req, res, false, undefined);
            }
        }
        verifyCallback(callbackBody, contentSignature)
            .then((verified) => {
            return cb(null, req, res, verified, Object.assign(callbackBody, { Entity: parsedEntity }));
        })
            .catch((err) => {
            return cb(err, req, res, false, undefined);
        });
    };
}
exports.middleware = middleware;
exports.default = { middleware, verifyCallback, verifyMessage };
//# sourceMappingURL=Callback.js.map