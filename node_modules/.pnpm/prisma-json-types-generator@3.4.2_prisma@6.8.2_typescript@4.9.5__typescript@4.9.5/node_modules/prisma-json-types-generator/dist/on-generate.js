"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onGenerate = onGenerate;
const tslib_1 = require("tslib");
const promises_1 = tslib_1.__importDefault(require("node:fs/promises"));
const node_path_1 = require("node:path");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const module_1 = require("./handler/module");
const statement_1 = require("./handler/statement");
const dmmf_1 = require("./helpers/dmmf");
const config_1 = require("./util/config");
const declaration_writer_1 = require("./util/declaration-writer");
const prisma_generator_1 = require("./util/prisma-generator");
const source_path_1 = require("./util/source-path");
/** Runs the generator with the given options. */
async function onGenerate(options) {
    try {
        const prismaClient = (0, prisma_generator_1.findPrismaClientGenerator)(options.otherGenerators);
        const config = (0, config_1.parseConfig)(options.generator.config);
        const isNewClient = (prismaClient.provider.fromEnvVar || prismaClient.provider.value) === 'prisma-client';
        if (isNewClient) {
            const modelsFolder = (0, node_path_1.join)(prismaClient.output.value, 'models');
            const stat = await promises_1.default.stat(modelsFolder).catch(() => null);
            // Models are split into multiple files starting in prisma@6.7
            if (stat?.isDirectory()) {
                for (const modelFile of await promises_1.default.readdir(modelsFolder)) {
                    await handleDeclarationFile((0, node_path_1.join)(modelsFolder, modelFile), config, options, prismaClient.config.importFileExtension?.toString(), true);
                }
                await promises_1.default.writeFile((0, node_path_1.join)(prismaClient.output.value, 'pjtg.ts'), await (0, declaration_writer_1.getNamespacePrelude)(config.namespace));
                return;
            }
        }
        const clientOutput = isNewClient
            ? (0, node_path_1.join)(prismaClient.output.value, 'client.ts')
            : (0, source_path_1.buildTypesFilePath)(prismaClient.output.value, config.clientOutput, options.schemaPath);
        await handleDeclarationFile(clientOutput, config, options, prismaClient.config.importFileExtension?.toString(), false);
    }
    catch (error) {
        console.error(error);
    }
}
async function handleDeclarationFile(filepath, config, options, importFileExtension, multifile) {
    const writer = new declaration_writer_1.DeclarationWriter(filepath, config, multifile, importFileExtension);
    // Reads the prisma declaration file content.
    await writer.load();
    const tsSource = typescript_1.default.createSourceFile(writer.filepath, writer.content, typescript_1.default.ScriptTarget.ESNext, true, typescript_1.default.ScriptKind.TS);
    const { typeToNameMap, modelMap, knownNoOps } = (0, dmmf_1.extractPrismaModels)(options.dmmf);
    // Handles the prisma namespace.
    tsSource.forEachChild((child) => {
        try {
            if (!multifile) {
                if (child.kind === typescript_1.default.SyntaxKind.ModuleDeclaration) {
                    (0, module_1.handlePrismaModule)(child, writer, modelMap, knownNoOps, typeToNameMap, config);
                }
            }
            else {
                if (typescript_1.default.isStatement(child)) {
                    (0, statement_1.handleStatement)(child, writer, modelMap, typeToNameMap, knownNoOps, config);
                }
            }
        }
        catch (error) {
            console.error(error);
        }
    });
    await writer.save();
}
//# sourceMappingURL=on-generate.js.map