"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleStatement = handleStatement;
const tslib_1 = require("tslib");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const regex_1 = require("../helpers/regex");
const model_payload_1 = require("./model-payload");
const replace_object_1 = require("./replace-object");
/**
 * Handles a Prisma namespace statement, can be a model type, a model payload or a model
 * where/create/update input/output
 */
function handleStatement(statement, writer, modelMap, typeToNameMap, knownNoOps, config) {
    if (statement.kind !== typescript_1.default.SyntaxKind.TypeAliasDeclaration) {
        return;
    }
    const type = statement;
    // Filters any statement that isn't a export type declaration
    if (type.type.kind !== typescript_1.default.SyntaxKind.TypeLiteral) {
        return;
    }
    // Skip the type if it belongs to a model without Json or a type comment
    if (knownNoOps.has(type.name.getText())) {
        return;
    }
    const typeName = type.name.getText();
    const modelName = typeToNameMap.get(typeName);
    // Extract the name of the model from the type name
    if (modelName) {
        const model = modelMap.get(modelName);
        if (model) {
            if (typeName === `$${modelName}Payload`) {
                return (0, model_payload_1.handleModelPayload)(type, writer, model, config);
            }
            return (0, replace_object_1.replaceObject)(type.type, writer, model, config);
        }
    }
    else {
        // If the type name isn't constant, match the model name using a regex, then do the lookup
        const baseName = (0, regex_1.extractBaseNameFromRelationType)(typeName);
        if (baseName) {
            const model = modelMap.get(baseName);
            if (model) {
                return (0, replace_object_1.replaceObject)(type.type, writer, model, config);
            }
        }
    }
}
//# sourceMappingURL=statement.js.map