"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPrismaModels = extractPrismaModels;
const regex_1 = require("./regex");
const type_parser_1 = require("./type-parser");
const isTransformable = (field) => {
    if (field.type === 'Json') {
        return true;
    }
    return (0, type_parser_1.parseTypeSyntax)(field.documentation);
};
/**
 * Parses the DMMF document and returns a list of models that have at least one field with
 * typed json and the regexes for each field type.
 */
function extractPrismaModels(dmmf) {
    const models = dmmf.datamodel.models
        // Define the regexes for each model
        .map((model) => ({
        ...model,
        type: 'model',
        regexps: (0, regex_1.createRegexForType)(model.name)
    }));
    const types = dmmf.datamodel.types.map((model) => ({
        ...model,
        type: 'type',
        regexps: (0, regex_1.createRegexForType)(model.name)
    }));
    const allModels = [];
    const knownNoOps = new Set();
    for (const m of models.concat(types)) {
        if (m.fields.some((f) => isTransformable(f))) {
            allModels.push(m);
        }
        else {
            knownNoOps.add(m.name);
        }
    }
    const typeToNameMap = new Map();
    for (const m of allModels) {
        const operations = (0, regex_1.generateTypeNamesFromName)(m.name);
        for (const o of operations) {
            typeToNameMap.set(o, m.name);
        }
    }
    const modelMap = new Map();
    for (const m of allModels) {
        modelMap.set(m.name, m);
    }
    return { typeToNameMap, modelMap, knownNoOps };
}
//# sourceMappingURL=dmmf.js.map