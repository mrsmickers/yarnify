"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRegexForType = createRegexForType;
exports.extractBaseNameFromRelationType = extractBaseNameFromRelationType;
exports.isUpdateOneType = isUpdateOneType;
exports.generateTypeNamesFromName = generateTypeNamesFromName;
/**
 * A list of regexes to match all types and subtypes generated by prisma for a specific
 * model
 */
function createRegexForType(name) {
    return [
        // new RegExp(`^${name}CountAggregate$`, 'm'),
        // new RegExp(`^${name}CountAggregateOutputType$`, 'm'), `number` fields
        // new RegExp(`^${name}CountOrderByAggregateInput$`, 'm'), `SortOrder` fields
        // new RegExp(`^${name}CountAggregateInputType$`, 'm'), `true` fields
        // new RegExp(`^${name}Group$`, 'm'),
        // new RegExp(`^${name}GroupByOutputType$`, 'm'),
        // new RegExp(`^${name}OrderByWithRelationInput$`, 'm'), `SortOrder` fields
        // new RegExp(`^${name}OrderByWithAggregationInput$`, 'm'), `SortOrder` fields
        // new RegExp(`^${name}(?:Scalar)?Where$`, 'm'),
        // new RegExp(`^${name}(?:Scalar)?WhereInput$`, 'm'),
        // new RegExp(`^${name}(?:Scalar)?WhereWithAggregatesInput$`, 'm'),
        // new RegExp(`^${name}(?:Unchecked)?CreateInput$`, 'm'),
        // new RegExp(`^${name}(?:Unchecked)?CreateManyInput$`, 'm'),
        new RegExp(`^${name}(?:Unchecked)?CreateWithout(?:\\w+?)Input$`, 'm'),
        new RegExp(`^${name}(?:Unchecked)?CreateMany(?:\\w+?)Input$`, 'm'),
        // new RegExp(`^${name}(?:Unchecked)?UpdateInput$`, 'm'),
        // new RegExp(`^${name}(?:Unchecked)?UpdateManyInput$`, 'm'),
        // new RegExp(`^${name}(?:Unchecked)?UpdateManyMutationInput$`, 'm'),
        new RegExp(`^${name}(?:Unchecked)?UpdateWithout(?:\\w+?)Input$`, 'm')
    ];
}
function extractBaseNameFromRelationType(typeName) {
    const createWithoutRegex = /^(.+?)(?:Unchecked)?CreateWithout(?:\w+?)Input$/m;
    const createManyRegex = /^(.+?)(?:Unchecked)?CreateMany(?:\w+?)Input$/m;
    const updateWithoutRegex = /^(.+?)(?:Unchecked)?UpdateWithout(?:\w+?)Input$/m;
    let match = typeName.match(createWithoutRegex);
    if (match?.[1]) {
        return match[1];
    }
    match = typeName.match(createManyRegex);
    if (match?.[1]) {
        return match[1];
    }
    match = typeName.match(updateWithoutRegex);
    if (match?.[1]) {
        return match[1];
    }
    return null;
}
/** If the provided type is a update one variant */
function isUpdateOneType(type) {
    return type.match(/UpdateInput$/m) || type.match(/UpdateWithout(?:\w+?)Input$/m);
}
/**
 * Generates a list of potential type names based on the regex patterns
 * used in `createRegexForType`. Note that types involving relation names
 * (e.g., `CreateWithout[Relation]Input`) are not generated by this function.
 *
 * @param name The base name (e.g., model name)
 * @returns An array of generated type names
 */
function generateTypeNamesFromName(name) {
    const types = [];
    types.push(`$${name}Payload`);
    // CountAggregate
    types.push(`${name}CountAggregate`);
    // GroupBy
    types.push(`${name}Group`);
    types.push(`${name}GroupByOutputType`);
    // Where types
    types.push(`${name}Where`, `${name}ScalarWhere`);
    types.push(`${name}WhereInput`, `${name}ScalarWhereInput`);
    types.push(`${name}WhereWithAggregatesInput`, `${name}ScalarWhereWithAggregatesInput`);
    // Create types (excluding relation-specific ones)
    types.push(`${name}CreateInput`, `${name}UncheckedCreateInput`);
    types.push(`${name}CreateManyInput`, `${name}UncheckedCreateManyInput`);
    // Update types (excluding relation-specific ones)
    types.push(`${name}UpdateInput`, `${name}UncheckedUpdateInput`);
    types.push(`${name}UpdateManyInput`, `${name}UncheckedUpdateManyInput`);
    types.push(`${name}UpdateManyMutationInput`, `${name}UncheckedUpdateManyMutationInput`);
    return types;
}
//# sourceMappingURL=regex.js.map