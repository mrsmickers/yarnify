/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * API Documentation
 * The API description
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { axiosInstance } from './axios-instance';
export type CallResponseDtoAnalysis = { [key: string]: unknown };

export interface CallResponseDto {
  id: string;
  callSid: string;
  companyId?: string;
  startTime: string;
  endTime?: string;
  duration?: number;
  /** URL to the stored transcript file */
  transcriptUrl?: string;
  /** Status of the call (e.g., PROCESSING, COMPLETED, FAILED) */
  callStatus: string;
  analysis?: CallResponseDtoAnalysis;
  createdAt: string;
  updatedAt: string;
  agentName?: string;
}

export interface CallMetricsDto {
  /** Total number of positive sentiment calls */
  totalPositiveSentiment: number;
  /** Total number of negative sentiment calls */
  totalNegativeSentiment: number;
  /** Total number of neutral sentiment calls */
  totalNeutralSentiment: number;
  /** Average AI confidence score across all calls */
  averageConfidence: number;
}

export interface PaginatedCallsResponseDto {
  data: CallResponseDto[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  metrics: CallMetricsDto;
}

export interface CompanyListItemDto {
  /** Company ID */
  id: string;
  /** Company Name */
  name: string;
}

export interface AgentListItemDto {
  /** Agent ID */
  id: string;
  /** Agent Name */
  name: string;
}

export interface RefreshTokenResponseDto {
  /** A message indicating the result of the refresh operation. */
  message: string;
  /** The new access token (also set as an HTTP-only cookie). */
  accessToken?: string;
}

export type CallAnalysisControllerGetCallsParams = {
/**
 * Page number for pagination
 */
page?: number;
/**
 * Number of items per page
 */
limit?: number;
/**
 * Start date for filtering (ISO 8601 format)
 */
startDate?: string;
/**
 * End date for filtering (ISO 8601 format)
 */
endDate?: string;
/**
 * Company ID to filter by
 */
companyId?: string;
/**
 * Agent ID to filter by
 */
agentId?: string;
/**
 * Sentiment to filter by (e.g., Positive, Negative, Neutral)
 */
sentiment?: string;
/**
 * Call status to filter by (e.g., PROCESSING, COMPLETED, FAILED)
 */
status?: string;
/**
 * Search term for call SID or other relevant fields
 */
searchTerm?: string;
};

export type AuthControllerCallbackParams = {
code: string;
};

export const appControllerGetHello = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1`, method: 'GET', signal
    },
      );
    }
  

export const getAppControllerGetHelloQueryKey = () => {
    return [`/api/v1`] as const;
    }

    
export const getAppControllerGetHelloInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof appControllerGetHello>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloInfiniteQueryError = unknown


export function useAppControllerGetHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appControllerGetHello>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appControllerGetHello>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appControllerGetHello>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHelloInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appControllerGetHello>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const storageControllerGetCallRecording = (
    callId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/storage/recordings/${callId}`, method: 'GET', signal
    },
      );
    }
  

export const getStorageControllerGetCallRecordingQueryKey = (callId: string,) => {
    return [`/api/v1/storage/recordings/${callId}`] as const;
    }

    
export const getStorageControllerGetCallRecordingInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof storageControllerGetCallRecording>>>, TError = void>(callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerGetCallRecordingQueryKey(callId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerGetCallRecording>>> = ({ signal }) => storageControllerGetCallRecording(callId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(callId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerGetCallRecordingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerGetCallRecording>>>
export type StorageControllerGetCallRecordingInfiniteQueryError = void


export function useStorageControllerGetCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerGetCallRecording>>>, TError = void>(
 callId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerGetCallRecording>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerGetCallRecording>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerGetCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerGetCallRecording>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerGetCallRecordingInfiniteQueryOptions(callId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStorageControllerGetCallRecordingQueryOptions = <TData = Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError = void>(callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerGetCallRecordingQueryKey(callId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerGetCallRecording>>> = ({ signal }) => storageControllerGetCallRecording(callId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(callId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerGetCallRecordingQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerGetCallRecording>>>
export type StorageControllerGetCallRecordingQueryError = void


export function useStorageControllerGetCallRecording<TData = Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError = void>(
 callId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetCallRecording<TData = Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerGetCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerGetCallRecording<TData = Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerGetCallRecording<TData = Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerGetCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerGetCallRecordingQueryOptions(callId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const storageControllerStreamCallRecording = (
    callId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/storage/recordings/stream/${callId}`, method: 'GET', signal
    },
      );
    }
  

export const getStorageControllerStreamCallRecordingQueryKey = (callId: string,) => {
    return [`/api/v1/storage/recordings/stream/${callId}`] as const;
    }

    
export const getStorageControllerStreamCallRecordingInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>>, TError = void>(callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerStreamCallRecordingQueryKey(callId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>> = ({ signal }) => storageControllerStreamCallRecording(callId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(callId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerStreamCallRecordingInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>>
export type StorageControllerStreamCallRecordingInfiniteQueryError = void


export function useStorageControllerStreamCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>>, TError = void>(
 callId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerStreamCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerStreamCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerStreamCallRecordingInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerStreamCallRecordingInfiniteQueryOptions(callId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStorageControllerStreamCallRecordingQueryOptions = <TData = Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError = void>(callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerStreamCallRecordingQueryKey(callId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>> = ({ signal }) => storageControllerStreamCallRecording(callId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(callId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerStreamCallRecordingQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>>
export type StorageControllerStreamCallRecordingQueryError = void


export function useStorageControllerStreamCallRecording<TData = Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError = void>(
 callId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerStreamCallRecording<TData = Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>,
          TError,
          Awaited<ReturnType<typeof storageControllerStreamCallRecording>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerStreamCallRecording<TData = Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerStreamCallRecording<TData = Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerStreamCallRecording>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerStreamCallRecordingQueryOptions(callId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const storageControllerDownloadCallTranscript = (
    callId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<string>(
      {url: `/api/v1/storage/transcripts/download/${callId}`, method: 'GET', signal
    },
      );
    }
  

export const getStorageControllerDownloadCallTranscriptQueryKey = (callId: string,) => {
    return [`/api/v1/storage/transcripts/download/${callId}`] as const;
    }

    
export const getStorageControllerDownloadCallTranscriptInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>>, TError = void>(callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerDownloadCallTranscriptQueryKey(callId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>> = ({ signal }) => storageControllerDownloadCallTranscript(callId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(callId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerDownloadCallTranscriptInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>>
export type StorageControllerDownloadCallTranscriptInfiniteQueryError = void


export function useStorageControllerDownloadCallTranscriptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>>, TError = void>(
 callId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>,
          TError,
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerDownloadCallTranscriptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>,
          TError,
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerDownloadCallTranscriptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerDownloadCallTranscriptInfinite<TData = InfiniteData<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>>, TError = void>(
 callId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerDownloadCallTranscriptInfiniteQueryOptions(callId,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getStorageControllerDownloadCallTranscriptQueryOptions = <TData = Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError = void>(callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStorageControllerDownloadCallTranscriptQueryKey(callId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>> = ({ signal }) => storageControllerDownloadCallTranscript(callId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(callId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StorageControllerDownloadCallTranscriptQueryResult = NonNullable<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>>
export type StorageControllerDownloadCallTranscriptQueryError = void


export function useStorageControllerDownloadCallTranscript<TData = Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError = void>(
 callId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>,
          TError,
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerDownloadCallTranscript<TData = Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>,
          TError,
          Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStorageControllerDownloadCallTranscript<TData = Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStorageControllerDownloadCallTranscript<TData = Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError = void>(
 callId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof storageControllerDownloadCallTranscript>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStorageControllerDownloadCallTranscriptQueryOptions(callId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const voipControllerProcessRecordingsByDate = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/voip/recordings/process`, method: 'GET', signal
    },
      );
    }
  

export const getVoipControllerProcessRecordingsByDateQueryKey = () => {
    return [`/api/v1/voip/recordings/process`] as const;
    }

    
export const getVoipControllerProcessRecordingsByDateInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVoipControllerProcessRecordingsByDateQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>> = ({ signal }) => voipControllerProcessRecordingsByDate(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VoipControllerProcessRecordingsByDateInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>>
export type VoipControllerProcessRecordingsByDateInfiniteQueryError = unknown


export function useVoipControllerProcessRecordingsByDateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>,
          TError,
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVoipControllerProcessRecordingsByDateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>,
          TError,
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVoipControllerProcessRecordingsByDateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useVoipControllerProcessRecordingsByDateInfinite<TData = InfiniteData<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVoipControllerProcessRecordingsByDateInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getVoipControllerProcessRecordingsByDateQueryOptions = <TData = Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVoipControllerProcessRecordingsByDateQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>> = ({ signal }) => voipControllerProcessRecordingsByDate(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VoipControllerProcessRecordingsByDateQueryResult = NonNullable<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>>
export type VoipControllerProcessRecordingsByDateQueryError = unknown


export function useVoipControllerProcessRecordingsByDate<TData = Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>,
          TError,
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVoipControllerProcessRecordingsByDate<TData = Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>,
          TError,
          Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVoipControllerProcessRecordingsByDate<TData = Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useVoipControllerProcessRecordingsByDate<TData = Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof voipControllerProcessRecordingsByDate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVoipControllerProcessRecordingsByDateQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a paginated list of calls with optional filters
 */
export const callAnalysisControllerGetCalls = (
    params?: CallAnalysisControllerGetCallsParams,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<PaginatedCallsResponseDto>(
      {url: `/api/v1/call-analysis/calls`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getCallAnalysisControllerGetCallsQueryKey = (params?: CallAnalysisControllerGetCallsParams,) => {
    return [`/api/v1/call-analysis/calls`, ...(params ? [params]: [])] as const;
    }

    
export const getCallAnalysisControllerGetCallsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>>, TError = unknown>(params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetCallsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>> = ({ signal }) => callAnalysisControllerGetCalls(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetCallsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>>
export type CallAnalysisControllerGetCallsInfiniteQueryError = unknown


export function useCallAnalysisControllerGetCallsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>>, TError = unknown>(
 params: undefined |  CallAnalysisControllerGetCallsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCallsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>>, TError = unknown>(
 params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCallsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>>, TError = unknown>(
 params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a paginated list of calls with optional filters
 */

export function useCallAnalysisControllerGetCallsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>>, TError = unknown>(
 params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetCallsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCallAnalysisControllerGetCallsQueryOptions = <TData = Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError = unknown>(params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetCallsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>> = ({ signal }) => callAnalysisControllerGetCalls(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetCallsQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>>
export type CallAnalysisControllerGetCallsQueryError = unknown


export function useCallAnalysisControllerGetCalls<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError = unknown>(
 params: undefined |  CallAnalysisControllerGetCallsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCalls<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError = unknown>(
 params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCalls<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError = unknown>(
 params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a paginated list of calls with optional filters
 */

export function useCallAnalysisControllerGetCalls<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError = unknown>(
 params?: CallAnalysisControllerGetCallsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCalls>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetCallsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a single call by ID
 */
export const callAnalysisControllerGetCallById = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<CallResponseDto>(
      {url: `/api/v1/call-analysis/calls/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getCallAnalysisControllerGetCallByIdQueryKey = (id: string,) => {
    return [`/api/v1/call-analysis/calls/${id}`] as const;
    }

    
export const getCallAnalysisControllerGetCallByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>>, TError = void>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetCallByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>> = ({ signal }) => callAnalysisControllerGetCallById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetCallByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>>
export type CallAnalysisControllerGetCallByIdInfiniteQueryError = void


export function useCallAnalysisControllerGetCallByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>>, TError = void>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCallByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>>, TError = void>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCallByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>>, TError = void>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single call by ID
 */

export function useCallAnalysisControllerGetCallByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>>, TError = void>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetCallByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCallAnalysisControllerGetCallByIdQueryOptions = <TData = Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetCallByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>> = ({ signal }) => callAnalysisControllerGetCallById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetCallByIdQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>>
export type CallAnalysisControllerGetCallByIdQueryError = void


export function useCallAnalysisControllerGetCallById<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError = void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCallById<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCallById<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single call by ID
 */

export function useCallAnalysisControllerGetCallById<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCallById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetCallByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Queue a call for reprocessing
 */
export const callAnalysisControllerReprocessCall = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/call-analysis/calls/${id}/reprocess`, method: 'POST', signal
    },
      );
    }
  


export const getCallAnalysisControllerReprocessCallMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof callAnalysisControllerReprocessCall>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof callAnalysisControllerReprocessCall>>, TError,{id: string}, TContext> => {

const mutationKey = ['callAnalysisControllerReprocessCall'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof callAnalysisControllerReprocessCall>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  callAnalysisControllerReprocessCall(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CallAnalysisControllerReprocessCallMutationResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerReprocessCall>>>
    
    export type CallAnalysisControllerReprocessCallMutationError = void

    /**
 * @summary Queue a call for reprocessing
 */
export const useCallAnalysisControllerReprocessCall = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof callAnalysisControllerReprocessCall>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof callAnalysisControllerReprocessCall>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getCallAnalysisControllerReprocessCallMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get a list of all companies for filter dropdown
 */
export const callAnalysisControllerGetCompanyList = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<CompanyListItemDto[]>(
      {url: `/api/v1/call-analysis/companies-list`, method: 'GET', signal
    },
      );
    }
  

export const getCallAnalysisControllerGetCompanyListQueryKey = () => {
    return [`/api/v1/call-analysis/companies-list`] as const;
    }

    
export const getCallAnalysisControllerGetCompanyListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetCompanyListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>> = ({ signal }) => callAnalysisControllerGetCompanyList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetCompanyListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>>
export type CallAnalysisControllerGetCompanyListInfiniteQueryError = unknown


export function useCallAnalysisControllerGetCompanyListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCompanyListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCompanyListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a list of all companies for filter dropdown
 */

export function useCallAnalysisControllerGetCompanyListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetCompanyListInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCallAnalysisControllerGetCompanyListQueryOptions = <TData = Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetCompanyListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>> = ({ signal }) => callAnalysisControllerGetCompanyList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetCompanyListQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>>
export type CallAnalysisControllerGetCompanyListQueryError = unknown


export function useCallAnalysisControllerGetCompanyList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCompanyList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetCompanyList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a list of all companies for filter dropdown
 */

export function useCallAnalysisControllerGetCompanyList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetCompanyList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetCompanyListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a list of all agents for filter dropdown
 */
export const callAnalysisControllerGetAgentList = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<AgentListItemDto[]>(
      {url: `/api/v1/call-analysis/agents-list`, method: 'GET', signal
    },
      );
    }
  

export const getCallAnalysisControllerGetAgentListQueryKey = () => {
    return [`/api/v1/call-analysis/agents-list`] as const;
    }

    
export const getCallAnalysisControllerGetAgentListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetAgentListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>> = ({ signal }) => callAnalysisControllerGetAgentList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetAgentListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>>
export type CallAnalysisControllerGetAgentListInfiniteQueryError = unknown


export function useCallAnalysisControllerGetAgentListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetAgentListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetAgentListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a list of all agents for filter dropdown
 */

export function useCallAnalysisControllerGetAgentListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetAgentListInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCallAnalysisControllerGetAgentListQueryOptions = <TData = Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallAnalysisControllerGetAgentListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>> = ({ signal }) => callAnalysisControllerGetAgentList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CallAnalysisControllerGetAgentListQueryResult = NonNullable<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>>
export type CallAnalysisControllerGetAgentListQueryError = unknown


export function useCallAnalysisControllerGetAgentList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetAgentList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>,
          TError,
          Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCallAnalysisControllerGetAgentList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a list of all agents for filter dropdown
 */

export function useCallAnalysisControllerGetAgentList<TData = Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callAnalysisControllerGetAgentList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCallAnalysisControllerGetAgentListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerLogin = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/auth/login`, method: 'GET', signal
    },
      );
    }
  

export const getAuthControllerLoginQueryKey = () => {
    return [`/api/v1/auth/login`] as const;
    }

    
export const getAuthControllerLoginInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerLogin>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerLoginQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerLogin>>> = ({ signal }) => authControllerLogin(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerLoginInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
export type AuthControllerLoginInfiniteQueryError = unknown


export function useAuthControllerLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerLogin>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerLogin>>,
          TError,
          Awaited<ReturnType<typeof authControllerLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerLogin>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerLogin>>,
          TError,
          Awaited<ReturnType<typeof authControllerLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerLogin>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerLoginInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerLogin>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerLoginInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerLoginQueryOptions = <TData = Awaited<ReturnType<typeof authControllerLogin>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerLoginQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerLogin>>> = ({ signal }) => authControllerLogin(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerLoginQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
export type AuthControllerLoginQueryError = unknown


export function useAuthControllerLogin<TData = Awaited<ReturnType<typeof authControllerLogin>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerLogin>>,
          TError,
          Awaited<ReturnType<typeof authControllerLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerLogin<TData = Awaited<ReturnType<typeof authControllerLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerLogin>>,
          TError,
          Awaited<ReturnType<typeof authControllerLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerLogin<TData = Awaited<ReturnType<typeof authControllerLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerLogin<TData = Awaited<ReturnType<typeof authControllerLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerLoginQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerCallback = (
    params: AuthControllerCallbackParams,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/auth/callback`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getAuthControllerCallbackQueryKey = (params: AuthControllerCallbackParams,) => {
    return [`/api/v1/auth/callback`, ...(params ? [params]: [])] as const;
    }

    
export const getAuthControllerCallbackInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerCallback>>>, TError = unknown>(params: AuthControllerCallbackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerCallback>>> = ({ signal }) => authControllerCallback(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerCallbackInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerCallback>>>
export type AuthControllerCallbackInfiniteQueryError = unknown


export function useAuthControllerCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCallback>>>, TError = unknown>(
 params: AuthControllerCallbackParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCallback>>,
          TError,
          Awaited<ReturnType<typeof authControllerCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCallback>>>, TError = unknown>(
 params: AuthControllerCallbackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCallback>>,
          TError,
          Awaited<ReturnType<typeof authControllerCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCallback>>>, TError = unknown>(
 params: AuthControllerCallbackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerCallbackInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerCallback>>>, TError = unknown>(
 params: AuthControllerCallbackParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerCallbackInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerCallbackQueryOptions = <TData = Awaited<ReturnType<typeof authControllerCallback>>, TError = unknown>(params: AuthControllerCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerCallback>>> = ({ signal }) => authControllerCallback(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerCallback>>>
export type AuthControllerCallbackQueryError = unknown


export function useAuthControllerCallback<TData = Awaited<ReturnType<typeof authControllerCallback>>, TError = unknown>(
 params: AuthControllerCallbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCallback>>,
          TError,
          Awaited<ReturnType<typeof authControllerCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerCallback<TData = Awaited<ReturnType<typeof authControllerCallback>>, TError = unknown>(
 params: AuthControllerCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerCallback>>,
          TError,
          Awaited<ReturnType<typeof authControllerCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerCallback<TData = Awaited<ReturnType<typeof authControllerCallback>>, TError = unknown>(
 params: AuthControllerCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerCallback<TData = Awaited<ReturnType<typeof authControllerCallback>>, TError = unknown>(
 params: AuthControllerCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerGetProfile = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/auth/profile`, method: 'GET', signal
    },
      );
    }
  

export const getAuthControllerGetProfileQueryKey = () => {
    return [`/api/v1/auth/profile`] as const;
    }

    
export const getAuthControllerGetProfileInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetProfile>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetProfile>>> = ({ signal }) => authControllerGetProfile(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerGetProfileInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetProfile>>>
export type AuthControllerGetProfileInfiniteQueryError = unknown


export function useAuthControllerGetProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetProfile>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetProfile>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetProfile>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerGetProfileInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetProfile>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerGetProfileInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof authControllerGetProfile>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetProfile>>> = ({ signal }) => authControllerGetProfile(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerGetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetProfile>>>
export type AuthControllerGetProfileQueryError = unknown


export function useAuthControllerGetProfile<TData = Awaited<ReturnType<typeof authControllerGetProfile>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetProfile<TData = Awaited<ReturnType<typeof authControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetProfile>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetProfile<TData = Awaited<ReturnType<typeof authControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAuthControllerGetProfile<TData = Awaited<ReturnType<typeof authControllerGetProfile>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetProfile>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerGetProfileQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerLogout = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/auth/logout`, method: 'POST', signal
    },
      );
    }
  


export const getAuthControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext> => {

const mutationKey = ['authControllerLogout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, void> = () => {
          

          return  authControllerLogout()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>
    
    export type AuthControllerLogoutMutationError = unknown

    export const useAuthControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Refresh access token using refresh token
 */
export const authControllerRefreshToken = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<RefreshTokenResponseDto>(
      {url: `/api/v1/auth/refresh`, method: 'GET', signal
    },
      );
    }
  

export const getAuthControllerRefreshTokenQueryKey = () => {
    return [`/api/v1/auth/refresh`] as const;
    }

    
export const getAuthControllerRefreshTokenInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerRefreshToken>>>, TError = void>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerRefreshTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerRefreshToken>>> = ({ signal }) => authControllerRefreshToken(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerRefreshTokenInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerRefreshToken>>>
export type AuthControllerRefreshTokenInfiniteQueryError = void


export function useAuthControllerRefreshTokenInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerRefreshToken>>>, TError = void>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerRefreshToken>>,
          TError,
          Awaited<ReturnType<typeof authControllerRefreshToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerRefreshTokenInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerRefreshToken>>>, TError = void>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerRefreshToken>>,
          TError,
          Awaited<ReturnType<typeof authControllerRefreshToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerRefreshTokenInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerRefreshToken>>>, TError = void>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Refresh access token using refresh token
 */

export function useAuthControllerRefreshTokenInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerRefreshToken>>>, TError = void>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerRefreshTokenInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions , queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerRefreshTokenQueryOptions = <TData = Awaited<ReturnType<typeof authControllerRefreshToken>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerRefreshTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerRefreshToken>>> = ({ signal }) => authControllerRefreshToken(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerRefreshTokenQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerRefreshToken>>>
export type AuthControllerRefreshTokenQueryError = void


export function useAuthControllerRefreshToken<TData = Awaited<ReturnType<typeof authControllerRefreshToken>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerRefreshToken>>,
          TError,
          Awaited<ReturnType<typeof authControllerRefreshToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerRefreshToken<TData = Awaited<ReturnType<typeof authControllerRefreshToken>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerRefreshToken>>,
          TError,
          Awaited<ReturnType<typeof authControllerRefreshToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerRefreshToken<TData = Awaited<ReturnType<typeof authControllerRefreshToken>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Refresh access token using refresh token
 */

export function useAuthControllerRefreshToken<TData = Awaited<ReturnType<typeof authControllerRefreshToken>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerRefreshToken>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerRefreshTokenQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
