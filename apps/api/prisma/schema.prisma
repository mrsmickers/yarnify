// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  output          = "../generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// call analysi
generator json {
  provider = "prisma-json-types-generator"
}

model Company {
  id            String   @id @default(cuid())
  name          String
  connectwiseId String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  calls         Call[]
  CallAnalysis  CallAnalysis[]
  processingLog ProcessingLog[]
}

model Agent {
  id            String         @id @default(cuid())
  name          String
  email         String?
  extension     String?        @unique
  entraUserId   String?        @unique // Link to EntraUser for login account mapping
  entraUser     EntraUser?     @relation(fields: [entraUserId], references: [id])
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  calls         Call[]
  keywordAlerts KeywordAlert[]

  @@index([entraUserId])
}

model Call {
  id                  String    @id @default(cuid())
  companyId           String?
  callSid             String
  callStatus          String
  callDirection       String?   // INBOUND, OUTBOUND, INTERNAL, UNKNOWN
  externalPhoneNumber String?   // The external party's phone number (client/prospect)
  startTime           DateTime
  endTime             DateTime?
  duration            Int?
  recordingUrl        String?
  transcriptUrl       String? // Path to the transcript in blob storage
  processingMetadata  Json?   // LLM provider/model info for each pipeline step
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  company Company? @relation(fields: [companyId], references: [id])

  analysis                CallAnalysis?             @relation(fields: [callAnalysisId], references: [id])
  callAnalysisId          String?                   @unique
  processingLog           ProcessingLog[]
  Agents                  Agent?                    @relation(fields: [agentsId], references: [id])
  agentsId                String?
  CallTranscriptEmbedding CallTranscriptEmbedding[]
  keywordAlerts           KeywordAlert[]

  @@index([companyId])
}

model CallAnalysis {
  id                String             @id @default(cuid())
  companyId         String?
  callId            String
  /// [CallAnalysisData]
  data              Json
  promptTemplateId  String?
  llmConfigId       String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  Company           Company?           @relation(fields: [companyId], references: [id])
  Call              Call?
  promptTemplate    PromptTemplate?    @relation("PromptUsedInCall", fields: [promptTemplateId], references: [id])
  llmConfig         LLMConfiguration?  @relation("LLMUsedInCall", fields: [llmConfigId], references: [id])

  @@index([callId])
  @@index([promptTemplateId])
  @@index([llmConfigId])
}

model ProcessingLog {
  id        String   @id @default(cuid())
  companyId String?
  callId    String
  status    String
  message   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Company Company? @relation(fields: [companyId], references: [id])
  Call    Call?    @relation(fields: [callId], references: [id])

  @@index([companyId])
}

model CallTranscriptEmbedding {
  id            String                      @id @default(cuid())
  createdAt     DateTime                    @default(now())
  updatedAt     DateTime                    @updatedAt
  call          Call                        @relation(fields: [callId], references: [id])
  callId        String // Foreign key to Call
  chunkSequence Int // Order of this chunk within the call's transcript
  embedding     Unsupported("vector(1536)") // For OpenAI text-embedding-ada-002
  modelName     String // e.g., "text-embedding-ada-002"

  @@unique([callId, chunkSequence])
  @@index([callId])
  @@index([callId, chunkSequence])
}

// User management for Entra ID authenticated users
model EntraUser {
  id           String    @id @default(cuid())
  oid          String?   @unique // Object ID from Microsoft Entra ID
  email        String    @unique
  displayName  String?
  department   String?
  role         String    @default("user") // 'admin' or 'user'
  enabled      Boolean   @default(true) // Can be disabled by admin
  lastLoginAt  DateTime?
  lastSyncedAt DateTime  @default(now())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  agent        Agent?    // Reverse relation for agent mapping

  @@index([email])
  @@index([oid])
  @@index([role])
  @@map("entra_users")
}

// Prompt templates for AI operations
model PromptTemplate {
  id          String   @id @default(cuid())
  name        String
  useCase     String // TRANSCRIPTION_REFINEMENT, CALL_ANALYSIS, CUSTOM
  content     String   @db.Text
  isActive    Boolean  @default(false)
  version     Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?

  usedInCalls CallAnalysis[] @relation("PromptUsedInCall")

  @@index([useCase])
  @@index([isActive])
  @@map("prompt_templates")
}

// LLM configuration for different use cases
model LLMConfiguration {
  id          String   @id @default(cuid())
  name        String
  useCase     String // TRANSCRIPTION, TRANSCRIPTION_REFINEMENT, CALL_ANALYSIS, EMBEDDINGS
  modelName   String
  provider    String   @default("openai")
  isActive    Boolean  @default(false)
  settings    Json // { temperature, max_tokens, top_p, frequency_penalty, etc. }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?

  usedInCalls CallAnalysis[] @relation("LLMUsedInCall")

  @@index([useCase])
  @@index([isActive])
  @@map("llm_configurations")
}

// Department-level keyword triggers for training alerts
model DepartmentKeywordTrigger {
  id              String   @id @default(cuid())
  department      String?
  keyword         String
  isActive        Boolean  @default(true)
  triggerType     String   @default("TRAINING_ALERT")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdBy       String?

  triggeredAlerts KeywordAlert[]

  @@index([department])
  @@index([isActive])
  @@map("department_keyword_triggers")
}

// Marketing sync automations (e.g. ConnectWise → Encharge)
model MarketingSync {
  id           String   @id @default(uuid())
  name         String
  description  String?
  sourceType   String   // e.g. "connectwise"
  destType     String   // e.g. "encharge"
  filterConfig Json     // JSON with the CW filter params
  tagName      String   // Tag to apply in Encharge
  schedule     String?  // Cron expression
  enabled      Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  runs         MarketingSyncRun[]

  @@map("marketing_syncs")
}

model MarketingSyncRun {
  id              String    @id @default(uuid())
  syncId          String
  sync            MarketingSync @relation(fields: [syncId], references: [id])
  status          String    // "running", "completed", "failed"
  triggeredBy     String    // "manual", "schedule"
  startedAt       DateTime  @default(now())
  completedAt     DateTime?
  contactsTotal   Int       @default(0)
  contactsCreated Int       @default(0)
  contactsUpdated Int       @default(0)
  contactsRemoved Int       @default(0)
  contactsSkipped Int       @default(0)
  contactsFailed  Int       @default(0)
  errorMessage    String?
  details         Json?

  @@index([syncId])
  @@map("marketing_sync_runs")
}

// Keyword alert instances when triggers are matched
model KeywordAlert {
  id          String   @id @default(cuid())
  callId      String
  triggerId   String
  agentId     String?
  matchedText String
  context     String   @db.Text
  reviewedAt  DateTime?
  reviewedBy  String?
  createdAt   DateTime @default(now())

  call    Call                     @relation(fields: [callId], references: [id])
  trigger DepartmentKeywordTrigger @relation(fields: [triggerId], references: [id])
  agent   Agent?                   @relation(fields: [agentId], references: [id])

  @@index([callId])
  @@index([triggerId])
  @@index([agentId])
  @@index([reviewedAt])
  @@map("keyword_alerts")
}

// ─── Auto-Triage ───────────────────────────────────────────────────────

/// Cached board category hierarchy (Type → Subtype → Item combos) from CW ServiceItem report
model TriageCache {
  id            String   @id @default(cuid())
  boardId       Int
  boardName     String
  /// JSON: { types: [{ id, name, subtypes: [{ name, items: [] }] }] }
  hierarchy     Json
  comboCount    Int      @default(0)
  lastRefreshed DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([boardId])
  @@map("triage_cache")
}

/// Product alias table for keyword → product matching
model ProductAlias {
  id                  String   @id @default(cuid())
  category            String   // Hardware, SaaS, Networking, etc.
  product             String   // e.g. "TZ Series", "SentinelOne"
  vendor              String   // e.g. "SonicWall"
  /// JSON array of keyword strings (some prefixed ^ for word-boundary match)
  keywords            Json     // string[]
  notes               String?  @db.Text // Context for LLM
  troubleshootingHints String? @db.Text
  isActive            Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@map("product_aliases")
}

/// Log of every auto-triage classification
model TriageLog {
  id              String   @id @default(cuid())
  ticketId        Int
  ticketSummary   String
  companyName     String?
  contactName     String?
  source          String?

  // Classification result
  board           String?
  type            String?
  subtype         String?
  item            String?
  priority        String?
  reasoning       String?  @db.Text
  troubleshooting String?  @db.Text

  // Matched products
  matchedProducts Json?    // string[]

  // Validation
  isValid         Boolean  @default(false) // All values validated against cache
  warnings        Json?    // string[] of validation warnings

  // Meta
  modelUsed       String?
  promptTokens    Int?
  completionTokens Int?
  responseTimeMs  Int?
  error           String?  @db.Text

  // Whether the note was posted to CW
  notePosted      Boolean  @default(false)
  notePostedAt    DateTime?

  createdAt       DateTime @default(now())

  @@index([ticketId])
  @@index([createdAt])
  @@map("triage_logs")
}

// ─── Resolution Knowledge Base ──────────────────────────────────────

/// A resolved ticket stored as an anonymised, embedded knowledge entry
model ResolutionEntry {
  id              String   @id @default(cuid())

  // Source ticket reference (not exposed to clients, only engineers)
  ticketId        Int
  ticketSummary   String
  closedAt        DateTime

  // Classification (mirrors triage fields)
  board           String?
  type            String?
  subtype         String?
  item            String?

  // Content (anonymised)
  summary         String   @db.Text  // Anonymised ticket summary
  description     String?  @db.Text  // Anonymised initial description
  resolution      String?  @db.Text  // Anonymised resolution notes
  combinedText    String   @db.Text  // summary + description + resolution (used for embedding)

  // Time metrics
  minutesToResolve Int?

  // Vector embedding (NVIDIA nv-embedqa-e5-v5, 1024 dims)
  embedding       Unsupported("vector(1024)")
  embeddingModel  String   @default("nvidia/nv-embedqa-e5-v5")

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([ticketId])
  @@index([closedAt])
  @@index([board])
  @@index([type])
  @@map("resolution_entries")
}

/// Tracks the last sync cursor for resolution KB ingestion
model ResolutionSyncState {
  id              String   @id @default("singleton")
  lastSyncAt      DateTime // Last ticket closedAt we synced up to
  totalSynced     Int      @default(0)
  lastRunAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("resolution_sync_state")
}
